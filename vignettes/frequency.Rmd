---
title: "Clonotype Frequencies"
date: '`r format(Sys.Date(), "%B %d %Y")`'
output:
  rmarkdown::html_vignette:
    toc_float: true
    toc_depth: 2
    vignette: >
      %\VignetteIndexEntry{Clonotype Frequencies}
      %\VignetteEncoding{UTF-8}
      %\VignetteEngine{knitr::rmarkdown}
---

```{r "setup", include = FALSE}
# Chunk opts
knitr::opts_chunk$set(
  collapse   = TRUE,
  comment    = "#>",
  warning    = FALSE,
  message    = FALSE,
  fig.width  = 8,
  fig.height = 4
)
```

<br>

This vignette provides detailed examples for quantifying differences in clonotype frequencies. For the examples shown below, we use data for splenocytes from BL6 and MD4 mice collected using the 10X Genomics scRNA-seq platform. MD4 B cells are monoclonal and specifically bind hen egg lysozyme.

```{r}
library(djvdj)
library(Seurat)
library(ggplot2)

# Add V(D)J data to object
vdj_dirs <- c(
  BL6 = system.file("extdata/splen/BL6_BCR", package = "djvdj"),
  MD4 = system.file("extdata/splen/MD4_BCR", package = "djvdj")
)

so <- splen_so |>
  import_vdj(vdj_dirs, define_clonotypes = "cdr3_gene")
```

<br>

## Calculating clonotype frequencies

To quantify clonotype frequencies and store the results in the object meta.data, the `calc_frequency()` function can be used. This will add columns showing the number of occurrences of each clonotype ('freq'), the percentage of cells sharing the clonotype ('pct'), and a label that can be used for plotting ('grp'). By default these calculations will be performed for all cells in the object.

```{r}
so_vdj <- so |>
  calc_frequency(data_col = "clonotype_id")
```

To calculate clonotype frequencies separately for samples or clusters, the `cluster_col` argument can be used. To do this just specify the name of the column containing the sample or cluster IDs for each cell.

```{r}
so_vdj <- so |>
  calc_frequency(
    data_col = "clonotype_id",
    cluster_col = "sample"
  )
```

When `cluster_col` is specified, an additional meta.data column ('shared') will be added indicating whether the clonotype is shared between multiple clusters.

```{r}
so_vdj |>
  slot("meta.data") |>
  head(2)
```

<br>

## Plotting clonotype frequencies

djvdj includes the `plot_clone_frequency()` function to visualize differences in clonotype frequency between samples or clusters. By default this will produce bargraphs. Plot colors can be adjusted using the `plot_colors` argument.

```{r}
so |>
  plot_clone_frequency(
    data_col = "clonotype_id",
    plot_colors = "#3182bd"
  )
```

Frequencies can be calculated and plotted separately for each sample or cluster using the `cluster_col` argument. The `panel_nrow` and `panel_scales` arguments can be used to add separate scales for each sample or to adjust the number of rows used to arrange plots.

As expected we see that most MD4 B cells share the same clonotype, while BL6 cells have a diverse repertoire.

```{r}
so |>
  plot_clone_frequency(
    data_col     = "clonotype_id",
    cluster_col  = "orig.ident",
    panel_scales = "free"
  )
```

Rank-abundance plots can also be generated by setting the `method` argument to 'line'. Most djvdj plotting functions return ggplot objects that can be further modified with ggplot2 functions. Here we further modify plot aesthetics using the `ggplot::theme()` function. Most djvdj plotting function also include the ability to transform the axis using the `trans` argument.

```{r}
so |>
  plot_clone_frequency(
    data_col    = "clonotype_id",
    cluster_col = "orig.ident",
    method      = "line",
    plot_colors = c(MD4 = "#fec44f", BL6 = "#3182bd"),
    trans       = "log10"         # log-transform axis
  ) +
  theme(aspect.ratio = 0.8)
```

<br>

## UMAP projections

By default `calc_frequency()` will divide clonotypes into groups based on frequency and add a column to the meta.data containing these group labels. Clonotype frequencies can be summarized on a UMAP projection by plotting the added 'grp' column using the generic plotting function `plot_features()`.

Cells that lack BCR data will be plotted as `NA`s, the color of these points can be adjusted using the `na_color` argument.

```{r, fig.width = 11}
# Create UMAP summarizing samples
mouse_gg <- so |>
  plot_features(feature = "orig.ident")

# Create UMAP summarizing clonotype frequencies
abun_gg <- so |>
  calc_frequency(
    data_col = "clonotype_id",
    cluster_col = "sample"
  ) |>
  plot_features(feature = "clonotype_id_grp")

mouse_gg + abun_gg
```

Highly abundant clonotypes can also be specifically labeled on a UMAP projection. To do this, add a new meta.data column with the desired label using the `mutate_vdj()` function. This function works in a similar manner as `dplyr::mutate()`, but will specifically modify the object meta.data and allows to the user to parse per-chain information for each cell.

```{r, fig.width = 11}
top_gg <- so |>
  mutate_vdj(
    top_clonotype = ifelse(
      clonotype_id == "clonotype56",
      clonotype_id,
      "other"
    )
  ) |>
  plot_features(
    feature     = "top_clonotype",
    plot_colors = c(other = "#fec44f", clonotype56 = "#3182bd")
  )

mouse_gg + top_gg
```

<br>

## Other frequency calculations

In addition to clonotype abundance, `calc_frequency()` can be used to summarize the frequency of any cell label present in the object. In this example we count the number of cells present for each cell type in each sample.

```{r}
so_vdj <- so |>
  calc_frequency(
    data_col = "cell_type",
    cluster_col = "sample"
  )
```

To plot the fraction of cells present for each cell type, we can use the generic plotting function, `plot_frequency()`. This will create stacked bargraphs summarizing each cell label present in the `data_col` column. The color of each group can be specified with the `plot_colors` argument.

```{r}
so |>
  plot_frequency(
    data_col    = "cell_type",
    cluster_col = "sample",
    plot_colors = c("#3182bd", "#fec44f", "#31a354")
  )
```

To summarize the number cells present for each cell type, set the `units` argument to 'frequency'. To create grouped bargraphs, set the `stack` argument to `FALSE`.

```{r}
so |>
  plot_frequency(
    data_col    = "cell_type",
    cluster_col = "sample",
    units       = "frequency",
    stack       = FALSE
  )
```

Frequency plots can also be separated based on an additional grouping variable such as treatment group (e.g. placebo vs drug) or disease status (e.g. healthy vs disease). This will generate boxplots with each point representing a label present in the `cluster_col` column. In this example we have 3 BL6 and 3 MD4 samples, so there are 3 points shown for each boxplot.

```{r, fig.width = 5}
so |>
  plot_frequency(
    data_col    = "cell_type",
    cluster_col = "sample",
    group_col   = "orig.ident",
    plot_colors = c(MD4 = "#fec44f", BL6 = "#3182bd")
  )
```

<br>

## Session info

```{r, echo = FALSE}
sessionInfo()
```
