% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mutate-vdj.R
\name{mutate_vdj}
\alias{mutate_vdj}
\title{Modify V(D)J data in object}
\usage{
mutate_vdj(
  input,
  ...,
  clonotype_col = global$clonotype_col,
  data_cols = NULL,
  return_df = FALSE,
  sep = global$sep
)
}
\arguments{
\item{input}{Single cell object or data.frame containing V(D)J data. If a
data.frame is provided, cell barcodes should be stored as row names.}

\item{...}{Name-value pairs to use for creating or modifying per-chain V(D)J
meta.data, e.g. mean_umis = mean(umis).

To allow for modification of per-chain V(D)J data, the data for each cell is
converted into a vector, e.g. 'IGH;IGK' is equivalent to c('IGH', 'IGK').
This allows R vector operations to be performed on the per-chain values.
Any operations that produce a result greater than length 1 need to be
returned as a list(), e.g. new_col = umis + 1 will return a new value for
each chain, to prevent an error this must be written as
new_col = list(umis + 1).}

\item{clonotype_col}{meta.data column containing clonotype IDs. This is used
to identify columns containing V(D)J data.}

\item{data_cols}{meta.data columns containing V(D)J data to modify. If NULL,
data are automatically selected by identifying columns that have NAs in the
same rows as clonotype_col.}

\item{return_df}{Return results as a data.frame. If FALSE, results will be
added to the input object.}

\item{sep}{Separator used for storing per cell V(D)J data. If NULL, columns
containing V(D)J data will not be converted to vectors for filtering.}
}
\value{
Object with modified meta.data
}
\description{
Modify per-chain V(D)J data for each cell. This function offers greater
flexibility than \code{\link[=summarize_vdj]{summarize_vdj()}}, but is less user-friendly.
}
\examples{
# Calculate mean reads and UMIs per cell
res <- mutate_vdj(
  vdj_so,
  mean_umis  = mean(umis),
  mean_reads = mean(reads)
)

head(slot(res, "meta.data"), 3)

# Calculate the total number of insertions + deletions for each chain
# we have to wrap our expression in list() since a value is returned for
# each chain
res <- mutate_vdj(
  vdj_sce,
  indels = list(all_ins + all_del)
)

head(slot(res, "colData"), 3)

# Create a new column showing the unique chains for each cell
res <- mutate_vdj(
  vdj_so,
  unique_chains = stringr::str_c(unique(chains), collapse = "_")
)

head(slot(res, "meta.data"), 3)

# Determine which cells have both an IGK and IGL chain
res <- mutate_vdj(
  vdj_sce,
  both_light = all(c("IGK", "IGL") \%in\% chains)
)

head(slot(res, "colData"), 1)

# Determine which cells have multiple light chains
res <- mutate_vdj(
  vdj_so,
  multi_light = sum(chains \%in\% c("IGK", "IGL")) > 1
)

head(slot(res, "meta.data"), 3)

}
