#' Import V(D)J data
#'
#' @param input Object containing single cell data, if set to NULL a data.frame
#' containing V(D)J results will be returned
#' @param vdj_dir Directory containing the output from cellranger vdj. A vector
#' or named vector can be given to load data from multiple runs. If a named
#' vector is given, the cell barcodes will be prefixed with the provided names.
#' This mimics the behavior of Seurat::Read10X().
#' @param prefix Prefix to add to new columns
#' @param filter_chains Only include chains with at least one productive and
#' full length contig.
#' @param filter_paired Only include clonotypes with paired chains. For TCR
#' data each clonotype must have at least one TRA and TRB chain, for BCR data
#' each clonotype must have at least one IGH chain and at least one IGK or IGL
#' chain.
#' @param define_clonotypes Define clonotype IDs based on V(D)J data. This is
#' useful if the V(D)J datasets being loaded do not have consistent clonotype
#' IDs, i.e., clonotype1 is not the same across samples. Possible values are:
#'
#' - 'cdr3aa', define clonotypes based on the CDR3 amino acid sequence
#' - 'cdr3nt', define clonotypes based on the CDR3 nucleotide sequence
#' - 'cdr3_gene', define clonotypes based on the combination of the CDR3
#' nucleotide sequence and the V(D)J genes.
#'
#' When defining clonotypes, only productive full length chains will be used.
#' Set to NULL (default) to use the clonotype IDs already present in the input
#' data.
#'
#' @param include_mutations Include information about the number of
#' insertions/deletions/mismatches for each chain. This requires the
#' concat_ref.bam file from cellranger vdj to be present the directory provided
#' to vdj_dir. If include_mutations is TRUE, filter_chains is also
#' automatically set TRUE since indel data is only available for productive
#' chains.
#' @param aggr_dir Path to cellranger aggr output. To include mutation
#' information for each chain, also provide paths to the original cellranger
#' vdj output directories using the vdj_dir argument.
#'
#' To correctly match cell barcodes to those in the object, gene expression
#' data for each sample must be loaded in the same order as the samples were
#' specified in the cellranger aggr config file. In addition, if loading
#' mutation data, sample paths provided to the vdj_dir argument must also be in
#' the same order as the samples were specified in the cellranger aggr config
#' file.
#'
#' @param sep Separator to use for storing per cell V(D)J data
#' @return Single cell object or data.frame with added V(D)J data
#'
#' @examples
#' # Loading multiple datasets
#' vdj_dir <- c(
#'   system.file("extdata/bcr_1/outs", package = "djvdj"),
#'   system.file("extdata/bcr_2/outs", package = "djvdj")
#' )
#'
#' vdj_so <- import_vdj(tiny_so, vdj_dir, include_mutations = FALSE)
#'
#' head(vdj_so@meta.data, 1)
#'
#' # Specifying cell prefixes
#' # if cell prefixes are not specified when loading multiple datasets,
#' # prefixes will be automatically generated in a similar manner as
#' # Seurat::Read10X
#' vdj_so <- import_vdj(
#'   tiny_so,
#'   vdj_dir = vdj_dir,
#'   include_mutations = FALSE
#' )
#'
#' head(vdj_so@meta.data, 1)
#'
#' # Specifying cell prefixes using vector names
#' # if a named vector is passed, the names will be used as the cell prefixes
#' vdj_dir <- c(
#'   "1" = system.file("extdata/bcr_1/outs", package = "djvdj"),
#'   "2" = system.file("extdata/bcr_2/outs", package = "djvdj")
#' )
#'
#' vdj_so <- import_vdj(tiny_so, vdj_dir, include_mutations = FALSE)
#'
#' head(vdj_so@meta.data, 1)
#'
#' # Only include V(D)J data for productive full length chains
#' vdj_so <- import_vdj(
#'   tiny_so,
#'   vdj_dir = vdj_dir,
#'   filter_chains = TRUE,
#'   include_mutations = FALSE
#' )
#'
#' head(vdj_so@meta.data, 1)
#'
#' # Only include V(D)J data for cells with paired chains
#' vdj_so <- import_vdj(
#'   tiny_so,
#'   vdj_dir = vdj_dir,
#'   filter_paired = TRUE,
#'   include_mutations = FALSE
#' )
#'
#' head(vdj_so@meta.data, 1)
#'
#' # Defining clonotypes
#' # this is useful if the original clonotype IDs are not consistent across
#' # datasets, i.e. clonotype1 is not the same for all samples
#' vdj_so <- import_vdj(
#'   tiny_so,
#'   vdj_dir = vdj_dir,
#'   define_clonotypes = "cdr3_gene",
#'   include_mutations = FALSE
#' )
#'
#' head(vdj_so@meta.data, 1)
#'
#' # Include mutation information for each chain
#' # this information will be included if the file concat_ref.bam is present
#' # including mutation information will cause data import to be slower
#' vdj_so <- import_vdj(
#'   tiny_so,
#'   vdj_dir = vdj_dir,
#'   include_mutations = TRUE
#' )
#'
#' head(vdj_so@meta.data, 1)
#'
#' # Using import_vdj outside of Seurat
#' # SingleCellExperiment objects are also compatible, or if an input object is
#' # omitted, a data.frame containing the V(D)J data will be returned
#' vdj_sce <- import_vdj(tiny_sce, vdj_dir)
#'
#' head(vdj_sce@colData, 1)
#'
#' vdj_df <- import_vdj(vdj_dir = vdj_dir, include_mutations = FALSE)
#'
#' head(vdj_df, 1)
#'
#' @export
import_vdj <- function(input = NULL, vdj_dir = NULL, prefix = "", filter_chains = TRUE,
                       filter_paired = FALSE, define_clonotypes = NULL, include_mutations = FALSE,
                       aggr_dir = NULL, sep = ";") {

  # Check that vdj_dir or aggr_dir is provided
  load_aggr <- !is.null(aggr_dir)

  if (is.null(vdj_dir) && !load_aggr) {
    stop("Must provide 'vdj_dir' or 'aggr_dir'")
  }

  # Check that vdj_dir is also provided when loading mutation data for
  # aggr results
  if (load_aggr && is.null(vdj_dir) && include_mutations) {
    warning(
      "To include V(D)J mutation data when loading cellranger aggr results,",
      " paths to the original cellranger vdj output directories must be",
      " provided to the vdj_dir argument."
    )

    include_mutations <- FALSE
  }

  # When including indel data, only use productive full length chains
  if (!filter_chains && include_mutations) {
    filter_chains <- TRUE

    warning(
      "When include_mutations is TRUE, filter_chains is also automatically ",
      "set TRUE since mutation data is only available for productive chains."
    )
  }

  # V(D)J columns to include
  cdr3_cols  <- c("cdr3", "cdr3_nt")  # list aa column first
  count_cols <- c("reads", "umis")
  gene_cols  <- c("v_gene", "d_gene", "j_gene", "c_gene")
  qc_cols    <- c("productive", "full_length")
  len_cols   <- paste0(cdr3_cols, "_length")

  # Columns containing per-cell info
  cell_cols <- c("barcode", "clonotype_id")

  # Optional aggr columns
  aggr_cols <- c("donor", "origin")

  # Columns containing per-chain info that needs to be collapsed for each cell
  sep_cols <- c(
    gene_cols, "chains",
    cdr3_cols, count_cols,
    qc_cols
  )

  # Set cell barcode prefixes
  if (!is.null(input)) {
    bcs <- .get_meta(input)[[CELL_COL]]

    prfx_df <- .extract_cell_prefix(bcs, strip_bcs = FALSE)
    prfx_df <- dplyr::distinct(prfx_df, prfx, sfx)

    prfxs <- prfx_df$prfx
    sfxs  <- prfx_df$sfx

    if (!is.null(names(vdj_dir))) {
      names(vdj_dir) <- paste0(names(vdj_dir), "_")

      obj_prfxs <- paste0(prfxs, collapse = ", ")
      vdj_prfxs <- paste0(names(vdj_dir), collapse = ", ")

      if (any(duplicated(prfxs))) {
        stop(
          "To match the provided cell prefixes (", vdj_prfxs, ") with those",
          " in the object (", obj_prfxs, "), the cell prefixes in the object",
          " cannot be duplicated."
        )
      }

      if (!all(names(vdj_dir) %in% prfxs)) {
        stop(
          "Provided cell barcode prefixes (", vdj_prfxs, ") do not match ",
          "those in input object (", obj_prfxs, ")."
        )
      }

      sfxs  <- sfxs[match(names(vdj_dir), prfxs)]
      prfxs <- names(vdj_dir)
    }

  # If no prefixes, auto-generate, do not add prefix if only one sample
  # Read10X() will add the prefix, "1_", "2_", "3_", etc. for each sample
  } else if (!is.null(vdj_dir)) {
    prfxs <- names(vdj_dir)

    if (is.null(prfxs)) {
      prfxs <- ""

      if (length(vdj_dir) > 1) {
        prfxs <- paste0(seq_along(vdj_dir), "_")
      }
    }

    sfxs <- rep("-1", length(vdj_dir))
  }

  # Load V(D)J data and add cell prefixes
  if (!is.null(aggr_dir)) {
    cell_cols <- c(cell_cols, aggr_cols)

    contigs <- .load_aggr_data(aggr_dir, prfxs, sfxs)
    contigs <- list(contigs)

  } else {
    contigs <- .load_vdj_data(vdj_dir, prfxs, sfxs)
  }

  # vdj_cols should have all columns that should be included in output
  vdj_cols <- c(cell_cols, sep_cols)

  # For genes replace NAs
  # if a chain is missing a V(D)J segment, the gene name will be left empty
  # when read into R this results in an NA
  contigs <- purrr::map(contigs, ~ {
    dplyr::mutate(.x, across(all_of(gene_cols), tidyr::replace_na, "None"))
  })

  # Filter for productive full length chains
  if (filter_chains) {
    contigs <- purrr::map(contigs, dplyr::filter, !!!syms(qc_cols))
  }

  # Add indel info for each contig
  # if indel data is included, always filter for productive contigs since most
  # non-productive contigs are missing indel data
  if (include_mutations) {

    # Fix contig_ids in contigs
    contigs <- purrr::map(
      contigs,
      mutate,
      contig_sfx = unlist(.str_extract_all(contig_id, "_contig_[0-9]+$")),
      contig_id  = paste0(barcode, contig_sfx),
      contig_sfx = NULL
    )

    # Load mutation data
    indels <- .load_muts(vdj_dir, prfxs, sfxs)

    if (!is.null(indels)) {
      if (!is.null(aggr_dir)) {
        indels <- list(dplyr::bind_rows(indels))
      }

      indel_cols <- names(indels[[1]])
      indel_cols <- indel_cols[indel_cols != "contig_id"]

      # Join indel data
      # NEED TO CHECK BARCODE OVERLAP HERE!!!
      indel_ctigs <- purrr::map2(
        contigs, indels,
        dplyr::left_join,
        by = "contig_id"
      )

      # Replace NAs with 0
      # contigs that did not have any mutations will have NAs
      indel_ctigs <- purrr::map(
        indel_ctigs,
        ~ mutate(
          .x,
          dplyr::across(all_of(indel_cols), tidyr::replace_na, 0)
        )
      )

      contigs    <- indel_ctigs
      count_cols <- c(count_cols, indel_cols)
      sep_cols   <- c(sep_cols, indel_cols)
      vdj_cols   <- c(vdj_cols, indel_cols)
    }
  }

  # Classify input data as TCR or BCR
  vdj_class <- purrr::map_chr(contigs, .classify_vdj)
  vdj_class <- unique(vdj_class)

  if (length(vdj_class) > 1) {
    bad_class <- paste0(vdj_class, collapse = ", ")

    stop(
      "Multiple data types detected (", bad_class, "), provided data must be ",
      "either TCR or BCR. To add both TCR and BCR data to the same object, ",
      "run import_vdj separately for each and use the 'prefix' argument to ",
      "add distinct column names."
    )
  }

  # Check cell barcode overlap
  # use map to check each sample separately
  # give warning for low overlap
  # bind contig data.frames
  contigs <- purrr::imap_dfr(contigs, ~ .check_overlap(input, .x, .y))

  # Check for 'exact_subclonotype_id' columns, not included in all versions of
  # cellranger
  if (identical(vdj_class, "BCR") && "exact_subclonotype_id" %in% colnames(contigs)) {
    cell_cols <- c(cell_cols, "exact_subclonotype_id")
    vdj_cols  <- c(vdj_cols, "exact_subclonotype_id")
  }

  # Calculate CDR3 length
  # report length 0 if there is no reported CDR3 sequence
  contigs <- dplyr::mutate(
    contigs,
    across(
      all_of(cdr3_cols),
      ~ ifelse(.x == "None", 0, nchar(.x)),
      .names = "{.col}_length"
    )
  )

  sep_cols <- c(sep_cols, len_cols)
  vdj_cols <- c(vdj_cols, len_cols)

  # Remove contigs that do not have an assigned clonotype_id
  n_remove <- contigs$clonotype_id
  n_remove <- n_remove[is.na(n_remove)]
  n_remove <- length(n_remove)

  if (n_remove > 0) {
    warning(
      n_remove, " contig(s) do not have an assigned clonotype_id, ",
      "these contigs will be removed."
    )

    contigs <- dplyr::filter(contigs, !is.na(clonotype_id))
  }

  # Select V(D)J columns to keep
  contigs <- dplyr::select(contigs, all_of(vdj_cols))

  # Check for NAs in data, additional NAs would indicate malformed input
  if (!all(stats::complete.cases(contigs))) {
    stop("Malformed input data, NAs are present, check input files.")
  }

  # Check if sep is already present in sep_cols
  sep <- .check_sep(contigs, sep_cols, sep)

  # Sum contig reads, UMIs, and mutations for chains since some chains are
  # supported by multiple contigs
  # In the vloupe browser the UMI count is summed, but the summed read count
  # and summed mutations do not always match
  grp_cols <- vdj_cols[!vdj_cols %in% count_cols]
  contigs  <- dplyr::group_by(contigs, !!!syms(grp_cols))

  contigs <- dplyr::summarize(
    contigs,
    across(all_of(count_cols), sum),
    .groups = "drop"
  )

  # Determine which clonotypes are paired
  contigs <- .identify_paired(contigs)

  cell_cols <- c(cell_cols, "paired")
  vdj_cols  <- c(vdj_cols, "paired")

  if (filter_paired) {
    contigs <- dplyr::filter(contigs, paired)
  }

  # Order chains and CDR3 sequences
  # when rows are collapsed, the cdr3 sequences must be in the same order for
  # every cell. This is required so the cdr3 columns can be used directly as
  # the clonotype ID
  contigs <- dplyr::arrange(
    contigs,
    barcode, chains, cdr3_nt
  )

  # Extract isotypes from c_gene for IGH chain (for BCR data only)
  if (vdj_class %in% c("BCR", "Multi")) {
    contigs <- .extract_isotypes(contigs)

    cell_cols <- c(cell_cols, "isotype")
    vdj_cols  <- c(vdj_cols,  "isotype")
  }

  # Collapse chains into a single row for each cell
  # include columns containing per-cell info groups so they are included in the
  # summarized results
  contigs <- dplyr::group_by(contigs, !!!syms(cell_cols))

  meta <- summarize(
    contigs,
    across(
      all_of(sep_cols),
      ~ paste0(as.character(.x), collapse = sep)
    ),
    n_chains = n(),
    .groups = "drop"
  )

  # Reorder columns
  meta <- dplyr::relocate(meta, paired, .after = "full_length")
  meta <- dplyr::relocate(meta, all_of(len_cols), .after = last(cdr3_cols))
  meta <- dplyr::relocate(meta, n_chains, .after = "chains")
  meta <- dplyr::relocate(meta, all_of(gene_cols), .after = last(len_cols))

  if (vdj_class %in% c("BCR", "Multi")) {
    meta <- dplyr::relocate(meta, isotype, .after = "c_gene")
  }

  # Check for duplicated cell barcodes
  if (any(duplicated(meta$barcode))) {
    stop(
      "Malformed input data, multiple clonotype_ids ",
      "are associated with the same cell barcode."
    )
  }

  # Allow user to redefine clonotypes
  res <- tibble::column_to_rownames(meta, "barcode")

  if (!is.null(define_clonotypes)) {
    clone_cols <- list(
      cdr3aa    = "cdr3",
      cdr3nt    = "cdr3_nt",
      cdr3_gene = c("cdr3_nt", gene_cols[gene_cols != "c_gene"])
    )

    if (!define_clonotypes %in% names(clone_cols)) {
      stop(
        "define_clonotypes must be one of ",
        paste0(names(clone_cols), collapse = ", "), "."
      )
    }

    clone_cols <- clone_cols[[define_clonotypes]]

    filt_chains <- NULL

    if (filter_chains) filt_chains <- qc_cols

    res <- define_clonotypes(
      res,
      data_cols     = clone_cols,
      filter_chains = filt_chains
    )
  }

  # Filter to only include cells with valid clonotype_id
  # cells with missing clonotype have a clonotype_id of 'None'
  res <- dplyr::filter(res, clonotype_id != "None")

  if (nrow(res) == 0) {
    warning("No valid clonotypes present, check input data.")
  }

  # Add prefix to V(D)J columns
  res <- dplyr::rename_with(res, ~ paste0(prefix, .x))

  # Add new meta.data to input object
  res <- .merge_meta(input, res)

  res
}

#' Load V(D)J data
#'
#' @param vdj_dir Directory containing the output from cellranger vdj. A vector
#' or named vector can be given to load data from several runs. If a named
#' vector is given, the cell barcodes will be prefixed with the provided names.
#' This mimics the behavior of the Read10X function found in the Seurat
#' package.
#' @param contig_file cellranger vdj output file containing data for each
#' contig annotation
#' @param chk_none Value of 'None' will be replaced with FALSE for the
#' specified columns and converted to logical
#' @return List containing one data.frame for each path provided to vdj_dir
#' @importFrom readr read_csv cols
#' @noRd
.load_vdj_data <- function(vdj_dir, cell_prfxs, cell_sfxs,
                           contig_file = "filtered_contig_annotations.csv",
                           chk_none = c("productive", "full_length")) {

  # Check for file and return path
  res <- purrr::map_chr(vdj_dir, .get_vdj_path, file = contig_file)

  # Load data
  res <- purrr::map(
    res,
    readr::read_csv,
    col_types = readr::cols(),
    progress  = FALSE
  )

  # Replace 'None' in productive with FALSE
  res <- purrr::imap(res, ~ {
    d <- dplyr::filter(.x, is_cell)

    d <- .replace_none(d, chk_none)

    d <- dplyr::rename(
      d,
      chains       = chain,
      clonotype_id = raw_clonotype_id
    )

    d
  })

  # Format cell barcode prefixes
  prfx_args <- list(
    df_in      = res,
    cell_prfxs = cell_prfxs,
    cell_sfxs  = cell_sfxs
  )

  # furrr::furrr_options(globals = FALSE)
  # future::plan(future::multisession, workers = 2)
  #
  # tictoc::tic()
  # crt_fn <- carrier::crate(
  #   my_fn = .format_cell_prefixes,
  #   function(...) my_fn(...)
  # )
  #
  # res <- purrr::pmap(prfx_args, crt_fn, bc_col = "barcode")
  # # res <- furrr::future_pmap(prfx_args, .format_cell_prefixes, bc_col = "barcode")
  # tictoc::toc()

  res <- purrr::pmap(prfx_args, .format_cell_prefixes, bc_col = "barcode")

  res
}

#' Load data from cellranger aggr
#'
#' @param aggr_dir Directory containing the output from cellranger aggr
#' @param contig_file cellranger aggr output file containing data for each
#' contig annotation
#' @param chk_none Value of 'None' will be replaced with FALSE for the
#' specified columns and converted to logical
#' @return data.frame
#' @importFrom readr read_csv cols
#' @noRd
.load_aggr_data <- function(aggr_dir, cell_prfxs, cell_sfxs, contig_file = "filtered_contig_annotations.csv",
                            chk_none = c("productive", "full_length")) {

  # Check for file and return path
  res <- .get_vdj_path(aggr_dir, file = contig_file)

  # Load data
  res <- readr::read_csv(
    res,
    col_types = readr::cols(),
    progress  = FALSE
  )

  # Filter for contigs in cells
  res <- dplyr::filter(res, is_cell)

  # Replace 'None' with FALSE for QC columns
  res <- .replace_none(res, chk_none)

  res <- dplyr::rename(
    res,
    chains       = chain,
    clonotype_id = raw_clonotype_id
  )

  # Format cell barcode prefixes
  res <- .format_cell_prefixes(
    res,
    bc_col     = "barcode",
    cell_prfxs = cell_prfxs,
    cell_sfxs  = cell_sfxs
  )

  res
}

#' Format cell barcode prefixes
#'
#' @param df_in data.frame
#' @param bc_col Column containing cell barcodes
#' @param prfxs Named vector containing new cell prefixes
#' @return data.frame with formatted barcodes
#' @importFrom stringr str_remove
#' @noRd
.format_cell_prefixes <- function(df_in, bc_col = "barcode", cell_prfxs, cell_sfxs) {

  # Extract current cell prefixes
  bcs <- df_in[[bc_col]]

  prfx_df <- .extract_cell_prefix(bcs, strip_bcs = TRUE)

  # Match old and new prefixes
  new <- dplyr::distinct(prfx_df, prfx, sfx)

  if (nrow(new) != length(cell_prfxs)) {
    stop(
      "The number of provided cell prefixes does not match the number of ",
      "unique prefixes present on barcodes."
    )
  }

  new$new_prfx <- cell_prfxs
  new$new_sfx  <- cell_sfxs

  prfx_df <- dplyr::left_join(prfx_df, new, by = c("prfx", "sfx"))

  # Format cell barcodes
  prfx_df <- dplyr::mutate(
    prfx_df,
    prfx = ifelse(is.na(new_prfx), prfx, new_prfx),
    sfx  = ifelse(is.na(new_sfx), sfx, new_sfx),
    bc   = paste0(prfx, bc, sfx)
  )

  df_in[[bc_col]] <- prfx_df$bc

  df_in
}

.extract_cell_prefix <- function(bcs, strip_bcs, bc_len = 16) {
  bc_re  <- paste0("[ATGCN]{", bc_len, "}")
  sep_re <- "[^[:alnum:]]"

  p <- .extract_pattern(bcs, paste0("^.+", sep_re, "(?=", bc_re, ")"))
  s <- .extract_pattern(bcs, paste0("(?<=", bc_re, ")", sep_re, ".+$"))

  res <- tibble::tibble(
    bc   = bcs,
    prfx = p,
    sfx  = s
  )

  # Would be nice to implement base R version of str_remove that accepts a
  # vector of patterns
  if (strip_bcs) {
    res <- dplyr::mutate(
      res,
      bc = stringr::str_remove(bc, paste0("^", prfx)),
      bc = stringr::str_remove(bc, paste0(sfx, "$"))
    )
  }

  res
}

.extract_pattern <- function(x, pattern) {
  res <- .str_extract_all(x, pattern)
  res <- map_chr(res, ~ ifelse(purrr::is_empty(.x), "", .x))

  res
}

#' Replace 'None' with FALSE
#'
#' @param df_in data.frame
#' @param clmns Columns to replace 'None' and convert to logical
#' @return data.frame
#' @noRd
.replace_none <- function(df_in, clmns) {

  clmns <- clmns[!map_lgl(df_in[clmns], is.logical)]

  if (purrr::is_empty(clmns)) return(df_in)

  res <- dplyr::mutate(
    df_in,
    dplyr::across(all_of(clmns), ~ {
      as.logical(stringr::str_replace(.x, "^None$", "FALSE"))
    })
  )

  res

  # WHY????
  # res <- dplyr::rowwise(df_in)
  #
  # res <- dplyr::mutate(
  #   res,
  #   dplyr::across(.cols = all_of(clmns), ~ {
  #     ifelse(
  #       !is.logical(.x),
  #       as.logical(gsub("None", "FALSE", .x)),
  #       .x
  #     )
  #   })
  # )
  #
  # res <- dplyr::ungroup(res)
  # res
}

#' Load mutation information for each contig
#'
#' @param vdj_dir Directory containing the output from cellranger vdj. A vector
#' or named vector can be given to load data from several runs. If a named
#' vector is given, the cell barcodes will be prefixed with the provided names.
#' This mimics the behavior of the Read10X function found in the Seurat
#' package.
#' @param bam_file bam file from cellranger vdj containing alignment data comparing
#' each contig with the germline reference
#' @return List containing one data.frame for each path provided to vdj_dir
#' @importFrom Rsamtools scanBam
#' @noRd
.load_muts <- function(vdj_dir, cell_prfxs, cell_sfxs, bam_file = "concat_ref.bam",
                       airr_file = "airr_rearrangement.tsv") {

  # Retrieve bam and airr file paths
  file_paths <- c(bam = bam_file, airr = airr_file)

  file_paths <- purrr::map(file_paths, ~ {
    fl <- .x

    purrr::map_chr(
      vdj_dir, .get_vdj_path,
      file = fl, warn = TRUE
    )
  })

  any_missing <- any(purrr::map_lgl(file_paths, ~ any(is.na(.x))))

  if (any_missing) {
    warning(
      "To add mutation data to object, ", bam_file, " and ", airr_file,
      " must be present for all samples, check that these files are in the",
      " provided directory paths, mutation data not added to object."
    )

    return(NULL)
  }

  # Extract mutations from bam file
  mut_coords <- purrr::map(file_paths$bam, .extract_mut_coords)

  # Extract VDJ coords from AIRR
  vdj_coords <- purrr::map(file_paths$airr, .extract_vdj_coords)

  # Map mutations to VDJ segments
  res <- purrr::map2(mut_coords, vdj_coords, .map_muts)

  # Extract cell barcode from contig_id
  id_re <- "^.+(?=_contig_[0-9]+$)"

  res <- purrr::map(
    res,
    mutate,
    barcode = unlist(.str_extract_all(contig_id, id_re))
  )

  # Format cell barcode prefixes
  prfx_args <- list(
    df_in      = res,
    cell_prfxs = cell_prfxs,
    cell_sfxs  = cell_sfxs
  )

  res <- purrr::pmap(prfx_args, .format_cell_prefixes, bc_col = "barcode")

  res <- purrr::map(
    res,
    mutate,
    contig_sfx = unlist(.str_extract_all(contig_id, "_contig_[0-9]+$")),
    contig_id  = paste0(barcode, contig_sfx),
    contig_sfx = NULL,
    barcode    = NULL
  )

  res
}

.extract_mut_coords <- function(bam_file) {

  bam_info <- Rsamtools::scanBam(bam_file)[[1]]

  wdths <- as.data.frame(bam_info$seq@ranges)$width

  bam_info <- tibble::tibble(
    cigar     = bam_info$cigar,
    contig_id = bam_info$qname,
    len       = wdths
  )

  bam_info <- dplyr::filter(
    bam_info,
    grepl("_contig_[0-9]+$", contig_id)
  )

  # Get 0-based coordinates for mutations
  # set width of deletion coordinates as 0
  res <- dplyr::mutate(
    bam_info,
    n    = .str_extract_all(cigar, "[0-9]+(?=[^0-9])"),
    type = .str_extract_all(cigar, "(?<=[0-9])[^0-9]{1}")
  )

  res <- tidyr::unnest(res, c(n, type))
  res <- dplyr::group_by(res, contig_id)

  res <- dplyr::mutate(
    res,
    n     = as.numeric(n),
    idx   = ifelse(type != "D", n, 0),
    end   = cumsum(idx),
    start = lag(end, default = 0)
  )

  res <- dplyr::ungroup(res)
  res <- dplyr::filter(res, type != "=")

  res <- dplyr::select(
    res,
    all_of(c("contig_id", "len", "start", "end", "type", "n"))
  )

  res
}

.extract_vdj_coords <- function(airr_file) {

  airr <- readr::read_tsv(
    airr_file,
    col_types = readr::cols(),
    progress  = FALSE
  )

  # Pull V(D)J gene coordinates from AIRR file
  # tidyr::extract is much faster than tidyr::separate
  coord_cols_re <- "^([vdjc])(?=_).*(?<=_)(start|end)$"

  res <- dplyr::select(
    airr,
    contig_id = sequence_id,
    dplyr::matches(coord_cols_re, perl = TRUE)
  )

  if (ncol(res) == 1) {
    stop("V(D)J coordinates not found, check ", airr_file)
  }

  res <- tidyr::pivot_longer(res, -contig_id)
  res <- dplyr::filter(res, !is.na(value))
  res <- tidyr::extract(res, name, c("seg", "pos"), coord_cols_re)
  res <- tidyr::pivot_wider(res, names_from = pos)

  res <- dplyr::mutate(
    res,
    start = start - 1,
    len   = end - start
  )

  res <- dplyr::select(
    res,
    all_of(c("contig_id", "len", "start", "end", "seg"))
  )

  res
}

.map_muts <- function(mut_coords, vdj_coords) {

  mut_key <- c(
    I = "ins",
    D = "del",
    X = "mis"
  )

  mut_coords <- dplyr::mutate(
    mut_coords,
    type = dplyr::recode(type, !!!mut_key)
  )

  # If no vdj_coords, return mutation totals
  if (identical(vdj_coords, NA)) {
    res <- all_muts %>%
      tidyr::pivot_wider(
        names_from  = type,
        values_from = n,
        values_fill = 0
      )

    res <- dplyr::mutate(
      res,
      across(
        starts_with("all_"),
        ~ .x / len,
        .names = "{.col}_freq"
      )
    )

    return(res)
  }

  # Intersect mutations with VDJ gene coordinates for each contig
  # some annotations overlap each other! Example: AAACCTGAGAACTGTA-1_contig_1
  # left_join + mutate is much faster than valr::bed_intersect, probably due
  # to the extreme number of "chromosomes"
  vdj_muts <- dplyr::left_join(
    mut_coords, vdj_coords,
    by     = "contig_id",
    suffix = c("", ".seg")
  )

  vdj_muts <- dplyr::filter(
    vdj_muts,
    start < end.seg &
    end   > start.seg
  )

  vdj_muts <- dplyr::mutate(
    vdj_muts,
    len = len.seg,

    new_start = ifelse(
      start >= start.seg, start, start.seg
    ),

    new_end = ifelse(
      end <= end.seg, end, end.seg
    ),

    new_end = ifelse(
      type == mut_key[["D"]], new_end + 1, new_end
    ),

    n = ifelse(
      type != mut_key[["D"]], new_end - new_start, n
    )
  )

  # Identify junction indels
  jxn_muts <- filter(vdj_muts, type %in% unname(mut_key[c("I", "D")]))

  jxn_muts <- mutate(
    jxn_muts,
    seg = case_when(
      seg == "v" & end.seg   == new_end   ~ "vd",
      seg == "d" & start.seg == new_start ~ "vd",
      seg == "d" & end.seg   == new_end   ~ "dj",
      seg == "j" & start.seg == new_start ~ "dj",
      TRUE ~ as.character(NA)
    )
  )

  jxn_muts <- dplyr::filter(jxn_muts, !is.na(seg))
  jxn_muts <- dplyr::select(jxn_muts, -len)

  vdj_muts <- bind_rows(vdj_muts, jxn_muts)

  # Summarize mutation counts
  vdj_muts <- dplyr::group_by(
    vdj_muts,
    contig_id, len, type, seg
  )

  vdj_muts <- dplyr::summarize(vdj_muts, n = sum(n), .groups = "drop")

  # Summarize total mutations and total length per contig
  # for each mutation type, sum total for v, d, j, and c segments, exclude jxns
  all_muts <- dplyr::filter(vdj_muts, !seg %in% c("vd", "dj"))
  all_muts <- dplyr::group_by(all_muts, contig_id, type)

  all_muts <- dplyr::summarize(
    all_muts,
    n       = sum(n),
    len     = sum(len),
    seg     = "all",
    .groups = "drop"
  )

  vdj_muts <- dplyr::bind_rows(vdj_muts, all_muts)
  res      <- tidyr::unite(vdj_muts, "type", seg, type, sep = "_")

  # Set final output columns
  freq_cols <- mut_cols <- c("v", "d", "j", "c", "all")
  jxn_cols  <- c("vd", "dj")

  mut_cols <- purrr::map(mut_cols, paste0, "_", mut_key)
  mut_cols <- purrr::reduce(mut_cols, c)

  jxn_cols <- purrr::map(jxn_cols, paste0, "_", unname(mut_key[c("I", "D")]))
  jxn_cols <- purrr::reduce(jxn_cols, c)
  mut_cols <- c(mut_cols, jxn_cols)

  freq_cols <- purrr::map_chr(freq_cols, paste0, "_", mut_key[["X"]])

  # Calculate mismatch frequency
  freq <- dplyr::filter(res, type %in% freq_cols)

  freq <- dplyr::mutate(
    freq,
    n    = round(n / len, 6),
    type = paste0(type, "_freq"),
    len  = NULL
  )

  res <- dplyr::bind_rows(res, freq)
  res <- dplyr::select(res, -len)

  res <- tidyr::pivot_wider(
    res,
    names_from  = type,
    values_from = n,
    values_fill = 0
  )

  # Add 0s for missing columns and set column order
  # these are segments with no mutations for any chain
  mut_cols <- c(mut_cols, paste0(freq_cols, "_freq"))

  missing_cols <- mut_cols[!mut_cols %in% names(res)]

  res[, missing_cols] <- 0

  res <- res[, c("contig_id", mut_cols)]

  res
}

#' Check for V(D)J data file in provided directory
#'
#' @param vdj_dir Directory containing the output from cellranger vdj
#' @param file Name of cellranger vdj output file
#' @param warn When the file is not found display a warning message instead of
#' an error
#' @return path to cellranger vdj output file
#' @noRd
.get_vdj_path <- function(vdj_dir, file, warn = FALSE) {

  path <- file.path(vdj_dir, file)

  if (!file.exists(path)) path <- paste0(path, ".gz")
  if (!file.exists(path)) path <- NA

  if (is.na(path)) {
    fun <- stop

    if (warn) fun <- warning

    fun(file, " not found in ", vdj_dir, ".")
  }

  path
}

#' Check for separator in data.frame
#'
#' @param df_in data.frame
#' @param sep_cols Names of columns to check for sep
#' @param sep Separator to use for storing V(D)J data
#' @return Separator with white space stripped
#' @noRd
.check_sep <- function(df_in, sep_cols, sep) {
  if (is.null(sep_cols)) {
    sep_cols <- colnames(df_in)
  }

  if (is.null(sep)) {
    return(sep)
  }

  if (!is.character(sep)) {
    stop("'sep' must be a character.")
  }

  sep <- gsub("[[:space:]]", "", sep)

  has_sep <- grepl(sep, df_in[, sep_cols, drop = FALSE], fixed = TRUE)

  if (any(has_sep)) {
    stop("The string '", sep, "' is already present in the input data, select a different value for 'sep'.")
  }

  sep
}

#' Determine whether TCR or BCR data were provided
#'
#' @param df_in data.frame containing V(D)J data formatted so that each row
#' represents a single contig
#' @param chain_col Column in input data containing chain identity
#' @return Character string indicating whether TCR or BCR data were provided
#' @noRd
.classify_vdj <- function(df_in, chain_col = "chains") {

  chains <- list(
    "TCR" = c("TRA", "TRB", "TRD", "TRG"),
    "BCR" = c("IGH", "IGK", "IGL")
  )

  n_chains <- purrr::imap(chains, ~ purrr::set_names(rep(.y, length(.x)), .x))
  n_chains <- purrr::flatten(n_chains)

  # Classify chains
  # remove values that do not match, such as chains with "None"
  n_chains <- n_chains[df_in[[chain_col]]]
  n_chains <- n_chains[!is.na(names(n_chains))]
  n_chains <- table(as.character(n_chains))

  # Error if no chains match
  if (is_empty(n_chains)) {
    chains <- unlist(chains, use.names = FALSE)
    chains <- paste0(chains, collapse = ", ")

    stop(
      "None of the expected chains (", chains, ") were found in '",
      chain_col, "', unable to determine whether TCR or BCR data were ",
      "provided."
    )
  }

  # Calculate fraction of BCR/TCR chains
  # set type if >50% match
  res <- n_chains / sum(n_chains)
  res <- names(res[res > 0.5])

  if (purrr::is_empty(res)) {
    res <- "Multi"

    warning(
      "Equal number of BCR (", n_chains[["BCR"]], ") and TCR (",
      n_chains[["TCR"]], ") chains detected, unable to determine data type."
    )
  }

  res
}

#' Check cell barcode overlap with object
#'
#' @param input Single cell object
#' @param meta meta.data to check against object
#' @param nm Sample name to use for messages
#' @param pct_min Warn user if the percent overlap is less than pct_min
#' @return input data
#' @noRd
.check_overlap <- function(input, meta, nm, pct_min = 25) {

  if (is.null(input)) {
    return(meta)
  }

  obj_meta  <- .get_meta(input)
  obj_cells <- obj_meta[[CELL_COL]]
  met_cells <- unique(meta$barcode)

  n_overlap   <- length(obj_cells[obj_cells %in% met_cells])
  pct_overlap <- round(n_overlap / length(met_cells), 2) * 100

  if (nm != "") nm <- paste0("'", nm, "' ")

  sgst_msg <- paste0(
    "are you using the correct cell barcode prefixes? If loading results ",
    "from cellranger aggr, check that gene expression data for each sample ",
    "was loaded into the object in the same order as the samples were ",
    "specified in the cellranger aggr config file."
  )

  if (identical(n_overlap, 0L)) {
    stop(nm, "cell barcodes do not match those in the object, ", sgst_msg)
  }

  if (pct_overlap < pct_min) {
    warning(
      "Only ", pct_overlap, "% (", n_overlap, ") of ", nm,
      "cell barcodes overlap with the provided object, ", sgst_msg
    )
  }

  meta
}

#' Identify clonotypes with paired chains
#'
#' @param df_in data.frame containing V(D)J data formatted so each row
#' represents a single contig
#' @return Input data.frame with paired column added
#' @noRd
.identify_paired <- function(df_in) {

  res <- dplyr::group_by(df_in, barcode)

  res <- dplyr::mutate(
    res,
    paired = (all(c("TRA", "TRB") %in% chains)) |
      ("IGH" %in% chains & any(c("IGL", "IGK") %in% chains))
  )

  res <- dplyr::ungroup(res)

  res
}

#' Add isotypes to V(D)J data
#'
#' @param df_in data.frame containing V(D)J data formatted so each row
#' represents a single contig
#' @param iso_col Column containing data to use for extracting isotypes
#' @param chain_col Column in input data containing chain identity
#' @return Input data.frame with isotype column added
#' @noRd
.extract_isotypes <- function(df_in, iso_col = "c_gene", chain_col = "chains") {

  # Pull data for isotypes
  isos <- df_in[[iso_col]]

  chains <- df_in[[chain_col]]

  idx <- chains == "IGH" & isos != "None"

  isos[idx] <- substr(isos[idx], 1, 4)

  isos[!idx] <- as.character(NA)

  # Identify cells with multiple isotypes
  iso_df <- df_in[, c("barcode", iso_col)]

  iso_df[iso_col] <- isos

  iso_df <- dplyr::distinct(iso_df, barcode, c_gene)
  iso_df <- stats::na.omit(iso_df)

  dups <- iso_df$barcode
  dups <- dups[duplicated(dups)]

  # Add isotypes to meta.data
  iso_df <- mutate(
    iso_df,
    isotype = ifelse(barcode %in% dups, "Multi", !!sym(iso_col))
  )

  isos <- purrr::set_names(
    iso_df$isotype,
    iso_df$barcode
  )

  res <- mutate(
    df_in,
    isotype = unname(isos[barcode]),
    isotype = tidyr::replace_na(isotype, "None")
  )

  res
}

#' Define clonotypes based on V(D)J data
#'
#' This will assign new clonotype IDs based on the combination of values
#' present in the provided columns
#'
#' @param input Single cell object or data.frame containing V(D)J data. If a
#' data.frame is provided, the cell barcodes should be stored as row names.
#' @param data_cols meta.data columns containing V(D)J data to use for defining
#' clonotypes
#' @param clonotype_col Name of column to use for storing clonotype IDs
#' @param filter_chains Column(s) to use for filtering chains prior to defining
#' clonotypes (e.g. productive, full_length). The column(s) must contain TRUE
#' or FALSE for each chain. If NULL, all chains are used when defining
#' clonotypes.
#' @param sep Separator used for storing per cell V(D)J data
#' @return Single cell object or data.frame with added clonotype IDs
#'
#' @examples
#' # Define clonotypes using the CDR3 nucleotide sequence
#' res <- define_clonotypes(
#'   vdj_so,
#'   data_cols = "cdr3_nt"
#' )
#'
#' head(res@meta.data, 1)
#'
#' # Define clonotypes based on the combination of the CDR3 nucleotide sequence
#' # and the V and J genes
#' res <- define_clonotypes(
#'   vdj_sce,
#'   data_cols = c("cdr3_nt", "v_gene", "j_gene")
#' )
#'
#' head(res@colData, 1)
#'
#' # Modify the name of the column used to store clonotype IDs
#' res <- define_clonotypes(
#'   vdj_so,
#'   data_cols = "cdr3_nt",
#'   clonotype_col = "NEW_clonotype_id"
#' )
#'
#' head(res@meta.data, 1)
#'
#' # When defining clonotypes only use chains that are productive
#' res <- define_clonotypes(
#'   vdj_sce,
#'   data_cols = "cdr3_nt",
#'   filter_chains = "productive"
#' )
#'
#' head(res@colData, 1)
#'
#' @export
define_clonotypes <- function(input, data_cols, clonotype_col = "clonotype_id",
                              filter_chains = c("productive", "full_length"), sep = ";") {

  # Get meta.data
  # overwrite exising clonotype_col if it has the same name
  meta <- .get_meta(input)

  meta <- dplyr::select(meta, -any_of(clonotype_col))

  all_cols <- c(data_cols, filter_chains)

  if (!all(all_cols %in% colnames(meta))) {
    stop(
      "Not all columns (", paste0(all_cols, collapse = ", "),
      ") are present in meta.data."
    )
  }

  # Remove cells with NAs for any data_cols
  vdj <- dplyr::filter(
    meta,
    dplyr::if_all(dplyr::all_of(all_cols), ~ !is.na(.x))
  )

  vdj <- dplyr::select(vdj, all_of(c(CELL_COL, all_cols)))

  # Only use values in data_cols that are TRUE for all filter_chains columns
  # first identify contigs TRUE for all filter_chains columns
  # subset each data_cols column based on .clone_idx
  if (!is.null(filter_chains)) {
    clmns <- syms(filter_chains)

    vdj <- tibble::column_to_rownames(vdj, CELL_COL)

    vdj <- mutate_vdj(
      vdj,
      .clone_idx = list(purrr::reduce(list(!!!clmns), ~ .x & .y)),

      dplyr::across(
        dplyr::all_of(data_cols),
        ~ paste0(.x[.clone_idx], collapse = ""),
        .names = ".clone_{.col}"
      ),

      clonotype_col = NULL,
      data_cols = all_cols
    )

    data_cols <- paste0(".clone_", data_cols)

    vdj <- .get_meta(vdj)
  }

  # Add new clonotype IDs
  vdj <- dplyr::mutate(
    vdj,
    .new_clone = paste(!!!syms(data_cols), sep = ""),
    .new_id    = rank(.new_clone, ties.method = "min"),

    !!sym(clonotype_col) := ifelse(
      .new_clone == "",
      "None",
      paste0("clonotype", .new_id)
    )
  )

  # Add new clonotype IDs to meta.data
  vdj  <- dplyr::select(vdj, all_of(c(CELL_COL, clonotype_col)))
  meta <- dplyr::left_join(meta, vdj, by = CELL_COL)

  res <- .add_meta(input, meta)

  res
}





# #' Load insertion/deletion information for each contig
# #'
# #' VERSION TO LOAD INDELS FROM CONCAT_REF BAM
# #'
# #' @param vdj_dir Directory containing the output from cellranger vdj. A vector
# #' or named vector can be given to load data from several runs. If a named
# #' vector is given, the cell barcodes will be prefixed with the provided names.
# #' This mimics the behavior of the Read10X function found in the Seurat
# #' package.
# #' @param bam_file bam file from cellranger vdj containing alignment data comparing
# #' each contig with the germline reference
# #' @return List containing one data.frame for each path provided to vdj_dir
# #' @importFrom Rsamtools scanBam
# #' @noRd
# .load_bam_indels <- function(vdj_dir, bam_file = "concat_ref.bam") {
#
#   .extract_indels <- function(bam_lst) {
#
#     res <- tibble::tibble(
#       cigar     = bam_lst[[1]]$cigar,
#       contig_id = bam_lst[[1]]$qname
#     )
#
#     res <- dplyr::filter(res, grepl("_contig_[0-9]+$", contig_id))
#
#     # Add indel columns
#     res <- dplyr::mutate(
#       res,
#       n_insertion = .extract_pat(cigar, "[0-9]+(?=I)"),
#       n_deletion  = .extract_pat(cigar, "[0-9]+(?=D)"),
#       n_mismatch  = .extract_pat(cigar, "[0-9]+(?=X)"),
#     )
#
#     res <- dplyr::select(res, -cigar)
#
#     res
#   }
#
#   .extract_pat <- function(string, pat) {
#     res <- purrr::map_dbl(string, ~ {
#       strg  <- .x
#       mtch  <- gregexpr(pat, strg, perl = TRUE)[[1]]
#       strts <- as.integer(mtch)
#       lens  <- attr(mtch, "match.length", exact = TRUE)
#
#       n <- purrr::map2_int(strts, lens, ~ {
#         x <- substr(strg, .x, .x + .y - 1)
#         x <- as.integer(x)
#         x
#       })
#
#       # Multiple indel sites will result in vector with length > 1
#       # sum bp from all sites and replace NAs with 0
#       n <- tidyr::replace_na(sum(n), 0)
#
#       n
#     })
#
#     res
#   }
#
#   # Check for file and return path
#   # if bam is missing for any sample, return NULL
#   # do not want extra NAs in the V(D)J data columns
#   res <- purrr::map_chr(vdj_dir, .get_vdj_path, file = bam_file, warn = TRUE)
#
#   if (any(is.na(res))) {
#     return(NULL)
#   }
#
#   # Load data
#   res <- purrr::map(res, Rsamtools::scanBam)
#
#   # Extract indel data
#   res <- purrr::map(res, .extract_indels)
#
#   res
# }

# #' Load insertion/deletion information for each contig
# #'
# #' @param vdj_dir Directory containing the output from cellranger vdj. A vector
# #' or named vector can be given to load data from several runs. If a named
# #' vector is given, the cell barcodes will be prefixed with the provided names.
# #' This mimics the behavior of the Read10X function found in the Seurat
# #' package.
# #' @param airr_file file following AIRR format from cellranger vdj
# #' @return List containing one data.frame for each path provided to vdj_dir
# #' @importFrom Rsamtools scanBam
# #' @noRd
# .load_airr_indels <- function(vdj_dir, airr_file = "airr_rearrangement.tsv") {
#
#   len_cols <- c("junction_aa_length", "junction_length")
#
#   # Check for file and return path
#   # if airr is missing for any sample, return NULL
#   # do not want extra NAs in the V(D)J data columns
#   res <- purrr::map_chr(vdj_dir, .get_vdj_path, file = airr_file, warn = TRUE)
#
#   if (any(is.na(res))) {
#     return(NULL)
#   }
#
#   # Load data
#   res <- purrr::map(
#     res,
#     readr::read_tsv,
#     col_types = readr::cols(),
#     progress  = FALSE
#   )
#
#   # Add indel columns
#   clmns <- c("_insertions", "_deletions", "_mismatches")
#
#   res <- purrr::map(res, ~ {
#     .x <- .extract_indels(.x, "v_cigar", "v_")
#     .x <- .extract_indels(.x, "d_cigar", "d_")
#     .x <- .extract_indels(.x, "j_cigar", "j_")
#
#     .x <- dplyr::select(
#       .x,
#       contig_id = sequence_id,
#       all_of(len_cols),
#       ends_with(clmns)
#     )
#
#     .x
#   })
#
#   # Sum indels
#   clmns <- purrr::set_names(clmns)
#   clmns <- map(clmns, ~ str_c(c("v", "d", "j"), .x))
#
#   res <- purrr::map(res, ~ {
#     .x <- dplyr::rowwise(.x)
#
#     .x <- mutate(
#       .x,
#       all_insertions = sum(!!!syms(clmns$`_insertions`)),
#       all_deletions  = sum(!!!syms(clmns$`_deletions`)),
#       all_mismatches = sum(!!!syms(clmns$`_mismatches`))
#     )
#
#     .x <- dplyr::ungroup(.x)
#
#     .x
#   })
#
#   res
# }
# .extract_indels <- function(df_in, clmn, prfx) {
#   new_clmns <- c(
#     insertions = "[0-9]+(?=I)",
#     deletions  = "[0-9]+(?=D)",
#     mismatches = "[0-9]+(?=X)"
#   )
#
#   names(new_clmns) <- paste0(prfx, names(new_clmns))
#
#   res <- df_in
#
#   for (i in seq_along(new_clmns)) {
#     new <- names(new_clmns[i])
#     pat <- new_clmns[[i]]
#
#     res <- mutate(
#       res,
#       !!sym(new) := .extract_pat(!!sym(clmn), pat)
#     )
#   }
#
#   res
# }
# .extract_pat <- function(string, pat) {
#   res <- purrr::map_dbl(string, ~ {
#     strg  <- .x
#     mtch  <- gregexpr(pat, strg, perl = TRUE)[[1]]
#     strts <- as.integer(mtch)
#     lens  <- attr(mtch, "match.length", exact = TRUE)
#
#     n <- purrr::map2_int(strts, lens, ~ {
#       x <- substr(strg, .x, .x + .y - 1)
#       x <- as.integer(x)
#       x
#     })
#
#     # Multiple indel sites will result in vector with length > 1
#     # sum bp from all sites and replace NAs with 0
#     n <- tidyr::replace_na(sum(n), 0)
#
#     n
#   })
#
#   res
# }

